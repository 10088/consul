// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/pbreplication/replication.proto

package pbreplication

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ReplicationStatus indicates the current status of a replication routine
type Status int32

const (
	Status_Ok    Status = 0
	Status_Error Status = 1
)

var Status_name = map[int32]string{
	0: "Ok",
	1: "Error",
}

var Status_value = map[string]int32{
	"Ok":    0,
	"Error": 1,
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b5fa2c3191b7deb4, []int{0}
}

// ReplicationType indicates which type of resource the replication routine is running
type Type int32

const (
	Type_ACLTokens       Type = 0
	Type_ACLRoles        Type = 1
	Type_ACLPolicies     Type = 2
	Type_LegacyACLs      Type = 3
	Type_ConfigEntries   Type = 4
	Type_Intentions      Type = 5
	Type_FederationState Type = 6
)

var Type_name = map[int32]string{
	0: "ACLTokens",
	1: "ACLRoles",
	2: "ACLPolicies",
	3: "LegacyACLs",
	4: "ConfigEntries",
	5: "Intentions",
	6: "FederationState",
}

var Type_value = map[string]int32{
	"ACLTokens":       0,
	"ACLRoles":        1,
	"ACLPolicies":     2,
	"LegacyACLs":      3,
	"ConfigEntries":   4,
	"Intentions":      5,
	"FederationState": 6,
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b5fa2c3191b7deb4, []int{1}
}

// ReplicationStatus holds all the status information about
// pertaining to replicating a singular type of resource
type Info struct {
	// Type is the type of resource this information pertains to
	Type Type `protobuf:"varint,1,opt,name=Type,proto3,enum=replication.Type" json:"Type,omitempty"`
	// Enabled indicates whether replication for this type should
	// be running on the leader server in the local datacenter
	Enabled bool `protobuf:"varint,2,opt,name=Enabled,proto3" json:"Enabled,omitempty"`
	// Running indicates whether the replication routines are currently
	// running on this server. This should only ever be true on the
	// leader server.
	Running bool `protobuf:"varint,3,opt,name=Running,proto3" json:"Running,omitempty"`
	// Status is the current status of replication routines
	Status Status `protobuf:"varint,4,opt,name=Status,proto3,enum=replication.Status" json:"Status,omitempty"`
	// Index is the Raft index of the primary datacenter that replication
	// has finished for. Any Raft logs appended after this index in the
	// primary dc have not yet been replicated.
	Index uint64 `protobuf:"varint,5,opt,name=Index,proto3" json:"Index,omitempty"`
	// LastStatusAt is the last time when the status was updated
	LastStatusAt *types.Timestamp `protobuf:"bytes,6,opt,name=LastStatusAt,proto3" json:"LastStatusAt,omitempty"`
	// LastError is the error message causing a failure in the most
	// recent replication round that encountered an error.
	LastError            string   `protobuf:"bytes,7,opt,name=LastError,proto3" json:"LastError,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Info) Reset()         { *m = Info{} }
func (m *Info) String() string { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()    {}
func (*Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5fa2c3191b7deb4, []int{0}
}
func (m *Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Info.Merge(m, src)
}
func (m *Info) XXX_Size() int {
	return m.Size()
}
func (m *Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Info proto.InternalMessageInfo

func (m *Info) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_ACLTokens
}

func (m *Info) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Info) GetRunning() bool {
	if m != nil {
		return m.Running
	}
	return false
}

func (m *Info) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_Ok
}

func (m *Info) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Info) GetLastStatusAt() *types.Timestamp {
	if m != nil {
		return m.LastStatusAt
	}
	return nil
}

func (m *Info) GetLastError() string {
	if m != nil {
		return m.LastError
	}
	return ""
}

type InfoList struct {
	PrimaryDatacenter    string   `protobuf:"bytes,1,opt,name=PrimaryDatacenter,proto3" json:"PrimaryDatacenter,omitempty"`
	Info                 []*Info  `protobuf:"bytes,2,rep,name=Info,proto3" json:"Info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InfoList) Reset()         { *m = InfoList{} }
func (m *InfoList) String() string { return proto.CompactTextString(m) }
func (*InfoList) ProtoMessage()    {}
func (*InfoList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5fa2c3191b7deb4, []int{1}
}
func (m *InfoList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfoList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfoList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfoList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoList.Merge(m, src)
}
func (m *InfoList) XXX_Size() int {
	return m.Size()
}
func (m *InfoList) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoList.DiscardUnknown(m)
}

var xxx_messageInfo_InfoList proto.InternalMessageInfo

func (m *InfoList) GetPrimaryDatacenter() string {
	if m != nil {
		return m.PrimaryDatacenter
	}
	return ""
}

func (m *InfoList) GetInfo() []*Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func init() {
	proto.RegisterEnum("replication.Status", Status_name, Status_value)
	proto.RegisterEnum("replication.Type", Type_name, Type_value)
	proto.RegisterType((*Info)(nil), "replication.Info")
	proto.RegisterType((*InfoList)(nil), "replication.InfoList")
}

func init() {
	proto.RegisterFile("proto/pbreplication/replication.proto", fileDescriptor_b5fa2c3191b7deb4)
}

var fileDescriptor_b5fa2c3191b7deb4 = []byte{
	// 466 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0x4d, 0x8b, 0xd3, 0x40,
	0x1c, 0xc6, 0x3b, 0xd9, 0x34, 0xdb, 0x4c, 0xf7, 0x25, 0x9d, 0xdd, 0x43, 0xa8, 0x12, 0xc3, 0xc2,
	0x42, 0x58, 0x25, 0x81, 0xf5, 0x2e, 0xc4, 0x58, 0xa1, 0x10, 0x70, 0x19, 0x7b, 0xf2, 0x22, 0x93,
	0x74, 0x9a, 0x0e, 0x9b, 0xce, 0x84, 0x99, 0x09, 0x58, 0xf0, 0xe4, 0xa7, 0xf0, 0x23, 0x79, 0xf4,
	0x23, 0x48, 0xbd, 0xf8, 0x31, 0x64, 0x92, 0x2d, 0x76, 0xd5, 0xdb, 0xfc, 0x9f, 0xdf, 0x93, 0xff,
	0xcb, 0x43, 0xe0, 0x75, 0x23, 0x85, 0x16, 0x49, 0x53, 0x48, 0xda, 0xd4, 0xac, 0x24, 0x9a, 0x09,
	0x9e, 0x1c, 0xbc, 0xe3, 0x8e, 0xa3, 0xf1, 0x81, 0x34, 0x7d, 0x56, 0x09, 0x51, 0xd5, 0x34, 0xe9,
	0x50, 0xd1, 0xae, 0x12, 0xcd, 0x36, 0x54, 0x69, 0xb2, 0x69, 0x7a, 0xf7, 0xf4, 0xb2, 0x12, 0x95,
	0xe8, 0x1b, 0x9b, 0x57, 0xaf, 0x5e, 0x7d, 0xb1, 0xa0, 0x3d, 0xe7, 0x2b, 0x81, 0xae, 0xa1, 0xbd,
	0xd8, 0x36, 0xd4, 0x07, 0x21, 0x88, 0xce, 0x6e, 0x27, 0xf1, 0xe1, 0x38, 0x03, 0x70, 0x87, 0x91,
	0x0f, 0x8f, 0x67, 0x9c, 0x14, 0x35, 0x5d, 0xfa, 0x56, 0x08, 0xa2, 0x11, 0xde, 0x97, 0x86, 0xe0,
	0x96, 0x73, 0xc6, 0x2b, 0xff, 0xa8, 0x27, 0x0f, 0x25, 0x7a, 0x0e, 0x9d, 0xf7, 0x9a, 0xe8, 0x56,
	0xf9, 0x76, 0xd7, 0xfc, 0xe2, 0x51, 0xf3, 0x1e, 0xe1, 0x07, 0x0b, 0xba, 0x84, 0xc3, 0x39, 0x5f,
	0xd2, 0x4f, 0xfe, 0x30, 0x04, 0x91, 0x8d, 0xfb, 0x02, 0xbd, 0x82, 0x27, 0x39, 0x51, 0xba, 0xf7,
	0xa4, 0xda, 0x77, 0x42, 0x10, 0x8d, 0x6f, 0xa7, 0x71, 0x7f, 0x74, 0xbc, 0x3f, 0x3a, 0x5e, 0xec,
	0x8f, 0xc6, 0x8f, 0xfc, 0xe8, 0x29, 0x74, 0x4d, 0x3d, 0x93, 0x52, 0x48, 0xff, 0x38, 0x04, 0x91,
	0x8b, 0xff, 0x08, 0x57, 0x1f, 0xe1, 0xc8, 0x64, 0x90, 0x33, 0xa5, 0xd1, 0x0b, 0x38, 0xb9, 0x93,
	0x6c, 0x43, 0xe4, 0xf6, 0x0d, 0xd1, 0xa4, 0xa4, 0x5c, 0x53, 0xd9, 0x85, 0xe2, 0xe2, 0x7f, 0x81,
	0x49, 0xcd, 0x7c, 0xe9, 0x5b, 0xe1, 0x51, 0x34, 0xfe, 0x2b, 0x35, 0x03, 0x70, 0x87, 0x6f, 0x9e,
	0xec, 0x13, 0x40, 0x0e, 0xb4, 0xde, 0xdd, 0x7b, 0x03, 0xe4, 0xc2, 0x61, 0x37, 0xdb, 0x03, 0x37,
	0x9f, 0xfb, 0xe4, 0xd1, 0x29, 0x74, 0xd3, 0x2c, 0x5f, 0x88, 0x7b, 0xca, 0x95, 0x37, 0x40, 0x27,
	0x70, 0x94, 0x66, 0x39, 0x16, 0x35, 0x55, 0x1e, 0x40, 0xe7, 0x70, 0x9c, 0x66, 0xf9, 0x9d, 0xa8,
	0x59, 0xc9, 0xa8, 0xf2, 0x2c, 0x74, 0x06, 0x61, 0x4e, 0x2b, 0x52, 0x6e, 0xd3, 0x2c, 0x57, 0xde,
	0x11, 0x9a, 0xc0, 0xd3, 0x4c, 0xf0, 0x15, 0xab, 0x66, 0x5c, 0x4b, 0x63, 0xb1, 0x8d, 0x65, 0xce,
	0x35, 0xe5, 0x66, 0x1b, 0xe5, 0x0d, 0xd1, 0x05, 0x3c, 0x7f, 0x4b, 0x97, 0x54, 0x76, 0xeb, 0x99,
	0x7d, 0xa8, 0xe7, 0xbc, 0x9e, 0x7d, 0xdb, 0x05, 0xe0, 0xfb, 0x2e, 0x00, 0x3f, 0x76, 0x01, 0xf8,
	0xb5, 0x0b, 0x06, 0x5f, 0x7f, 0x06, 0x83, 0x0f, 0x49, 0xc5, 0xf4, 0xba, 0x2d, 0xe2, 0x52, 0x6c,
	0x92, 0x35, 0x51, 0x6b, 0x56, 0x0a, 0xd9, 0x24, 0xa5, 0xe0, 0xaa, 0xad, 0x93, 0xff, 0xfc, 0x9d,
	0x85, 0xd3, 0x89, 0x2f, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0xdf, 0x00, 0xcf, 0x7f, 0xbb, 0x02,
	0x00, 0x00,
}

func (m *Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastError) > 0 {
		i -= len(m.LastError)
		copy(dAtA[i:], m.LastError)
		i = encodeVarintReplication(dAtA, i, uint64(len(m.LastError)))
		i--
		dAtA[i] = 0x3a
	}
	if m.LastStatusAt != nil {
		{
			size, err := m.LastStatusAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReplication(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Index != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x28
	}
	if m.Status != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Running {
		i--
		if m.Running {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintReplication(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfoList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReplication(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PrimaryDatacenter) > 0 {
		i -= len(m.PrimaryDatacenter)
		copy(dAtA[i:], m.PrimaryDatacenter)
		i = encodeVarintReplication(dAtA, i, uint64(len(m.PrimaryDatacenter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintReplication(dAtA []byte, offset int, v uint64) int {
	offset -= sovReplication(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovReplication(uint64(m.Type))
	}
	if m.Enabled {
		n += 2
	}
	if m.Running {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovReplication(uint64(m.Status))
	}
	if m.Index != 0 {
		n += 1 + sovReplication(uint64(m.Index))
	}
	if m.LastStatusAt != nil {
		l = m.LastStatusAt.Size()
		n += 1 + l + sovReplication(uint64(l))
	}
	l = len(m.LastError)
	if l > 0 {
		n += 1 + l + sovReplication(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InfoList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrimaryDatacenter)
	if l > 0 {
		n += 1 + l + sovReplication(uint64(l))
	}
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovReplication(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovReplication(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozReplication(x uint64) (n int) {
	return sovReplication(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Running", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Running = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStatusAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastStatusAt == nil {
				m.LastStatusAt = &types.Timestamp{}
			}
			if err := m.LastStatusAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReplication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryDatacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryDatacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReplication
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReplication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &Info{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReplication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthReplication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReplication(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReplication
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReplication
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthReplication
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthReplication
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowReplication
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipReplication(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthReplication
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthReplication = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReplication   = fmt.Errorf("proto: integer overflow")
)
